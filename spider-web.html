<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态蜘蛛网效果</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            background: #000;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let mouseX = 0;
        let mouseY = 0;

        // 设置canvas尺寸为全屏
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 监听鼠标移动
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });

        // 蜘蛛网类
        class SpiderWeb {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.lines = Math.floor(Math.random() * 5) + 6; // 6-10条线
                this.maxRadius = Math.random() * 30 + 30; // 30-60的半径
                this.points = [];
                this.angleStep = (Math.PI * 2) / this.lines;
                this.time = Math.random() * 1000; // 随机初始时间
                this.speed = Math.random() * 0.02 + 0.01; // 随机速度
                this.moveSpeed = 0.05;
                
                // 初始化端点
                for (let i = 0; i < this.lines; i++) {
                    this.points.push({
                        angle: this.angleStep * i,
                        radius: Math.random() * this.maxRadius,
                        phase: Math.random() * Math.PI * 2 // 随机相位
                    });
                }
            }

            update() {
                this.time += this.speed;
                
                // 检查鼠标距离
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // 如果鼠标靠近（200像素内），设置新的目标位置
                if (distance < 200) {
                    this.targetX = mouseX;
                    this.targetY = mouseY;
                } else {
                    // 返回原始位置
                    this.targetX = this.x;
                    this.targetY = this.y;
                }
                
                // 平滑移动
                this.x += (this.targetX - this.x) * this.moveSpeed;
                this.y += (this.targetY - this.y) * this.moveSpeed;

                // 更新每条线的端点位置，加入随机波动
                this.points.forEach(point => {
                    point.radius = (Math.sin(this.time + point.phase) * 0.5 + 1) * this.maxRadius;
                });
            }

            draw() {
                ctx.beginPath();
                ctx.strokeStyle = `rgba(255, 255, 255, ${Math.random() * 0.3 + 0.2})`; // 随机透明度
                ctx.lineWidth = Math.random() + 0.5; // 随机线宽
                
                // 绘制放射状线条
                this.points.forEach(point => {
                    const endX = this.x + Math.cos(point.angle) * point.radius;
                    const endY = this.y + Math.sin(point.angle) * point.radius;
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(endX, endY);
                });

                // 绘制连接线
                for (let i = 0; i < this.points.length; i++) {
                    const current = this.points[i];
                    const next = this.points[(i + 1) % this.points.length];
                    const x1 = this.x + Math.cos(current.angle) * current.radius;
                    const y1 = this.y + Math.sin(current.angle) * current.radius;
                    const x2 = this.x + Math.cos(next.angle) * next.radius;
                    const y2 = this.y + Math.sin(next.angle) * next.radius;
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                }

                ctx.stroke();
                
                // 绘制中心点
                ctx.beginPath();
                ctx.fillStyle = 'white';
                ctx.arc(this.x, this.y, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 创建多个蜘蛛网
        const webs = [];
        for (let i = 0; i < 10; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            webs.push(new SpiderWeb(x, y));
        }

        // 动画循环
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            webs.forEach(web => {
                web.update();
                web.draw();
            });

            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>